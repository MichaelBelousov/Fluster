/* Fluster Bison Grammar */

%require "3.4"
%language "c++" /* generates C++ */

%define api.namespace {yy}
%define api.parser.class {Parser}
%define api.value.type variant
%define api.token.constructor

%define parse.trace
%define parse.error verbose
%define parse.assert

%locations
%define api.location.file "location.gen.h"
%defines "parser.gen.h"
%output "parser.gen.cpp"
%printer { yyo << $$; } <*>;

%parse-param { yy::Lexer& lexer }  //construct parser object with lexer

%param { Driver& driver }

/* code in this block goes in parser.gen.h */
%code requires {
  #include "driver.h"
  namespace yy {
    class Lexer;  // reflex --namespace=yy --lexer=Lexer --lex=yylex
  };
  #undef yylex  //unlink the global yylex
  #define yylex lexer.lex  //within bison's parse invoke lexer.yylex()
}

%code top {
  #include <iostream>
  #include <string>

  #include "ast/base.h"
  #include "atoms/types.h"
  //XXX: remove this so inclusion doesn't use the namespace!
  namespace ast = fluster::ast;
  namespace atoms = fluster::atoms;
}

%code {
  #include "driver.h"
  #include "lexer.gen.h"
  #include "location.gen.h"
  using namespace fluster;
}

/*** Tokens ***/

/* control tokens */
%token      END             0   "End of file"
%token      INDENT
%token      OUTDENT
%token      NL                  "\n"

/* grouping */
%left       SEQ_EXEC                /* a; b */
            LIST                    /* a, b, c */
;

/* assignment */
%right      ASSIGN                  /* value assignment */

/* anonymous functions */
%right      LAMBDA

/* type assertion */
%left       TYPE_ASSERT             /* a: T */

/* arithmetic */
%left       DISJUNCT                /* | */
%left       CONJUNCT                /* & */
%left       IMPLY                   /* -> */
%left       EQ_RELATIONAL           /* ==, !=, #=, !#= */
%nonassoc   NON_EQ_RELATIONAL       /* <=>, <, <=, >=, > */
%left       LSHIFT
            RSHIFT
;
%left       ADD
            SUB
;
%left       MULT                    /* * */
            DIV                     /* / // */
            MOD                     /* % mod // */
;
%left       POW                     /* a ^ b */
            ROOT                    /* a ^/ b */
;

/* comparision/relational tokens */
%nonassoc   LANGLE              "<"         /* less than */
            LANGLE_EQ           "<="        /* less than or equal to */
            EQ_EQ               "=="        /* value comparison */
            EXCLAIM_EQ          "!="        /* complement of value comparison */
            HASH_EQ             "#="        /* identity comparision */
            LANGLE_EQ_RANGLE    "<=>"       /* ternary comparison */
            RANGLE_EQ           ">="        /* greater than or equal to */
            RANGLE              ">"         /* greater than */
;

/* prefix operations */
%right      COMPLEMENT          /* ~a */
            NEGATE              /* -a */
            TYPE_MUT            /* !T */
            TYPE_ARRAY          /* [N]T */
            TYPE_PTR            /* *T */
            TYPE_REF            /* &T */
            IS_OP               /* is T */
            HAS_OP              /* has T */
            UNARY_MINUS         /* -a */
            SQUARE_ROOT         /* ^/a */
            PREINCREMENT        /* ++a */
            PREDECREMENT        /* --a */
            SPREAD              /* ...a */
            CLONEOF
            TYPEOF
            IMPORT
            COMPOSE             /* @a */
;

/* postfix operations */
%left
            POSTINCREMENT       /* a++ */
            POSTDECREMENT       /* a-- */
            INVOKE              /* a() */
            SUBSCRIPT           /* a[] */
            PARAMETRIZE         /* a<> */
            ACCESS              /* a._ */
;

%token      IN                  "in"        /* containment expression */
%token      CONTAINS            "contains"  /* containment expression */
%token      MOD                 "mod"       /* modular division */
%token      IF                  "if"        /* start if statement */
%token      ELSE                "else"      /* start else statement */
%token      ELIF                "elif"      /* start else if statement */
%token      FOR                 "for"       /* start for loop */
%token      WHILE               "while"     /* start while loop */
%token      UNTIL               "until"     /* start until loop */
%token      REPEAT              "repeat"    /* start infinite loop */
%token      TRY                 "try"       /* attempt expression */
%token      RETRY               "retry"     /* retry attempted expression */
%token      HANDLE              "handle"    /* declare exception handling case */
%token      RAISE               "raise"     /* raise an exception case */
%token      WITH                "with"      /* declare context */
%token      STRUCT              "struct"    /* declare structure */
%token      CLASS               "class"     /* declare dynamic-type reference structure */
%token      TYPEOF              "typeof"    /* get type of expression */
%token      CLONEOF             "cloneof"   /* get clone of type */
%token      IMPORT              "import"    /* import a path */
/*ast::Identifier*/
%token <ast::Identifier> Identifier
%token <atoms::NaturalNumber> Integer_literal
%token <atoms::RationalNumber> Float_literal
%token <atoms::ByteArray> Bytes_literal
%token <atoms::BitArray> Bits_literal
%token <atoms::String> String_literal

%type <ast::Node::Ptr> expr
%type <ast::Node::Ptr> statement
%type <ast::Node::Ptr> lambda_body
%type <ast::Node::Ptr> code
%type <ast::Node::Ptr> block
%type <ast::Node::Ptr> if
%type <ast::Node::Ptr> if_follow_up
%type <ast::Node::Ptr> line
%type <ast::Node::Ptr> lambda_expr
%type <ast::Node::Ptr> commalist_
%type <ast::Node::Ptr> commalist
%type <ast::Node::Ptr> Par_list
%type <ast::Node::Ptr> Brack_list
%type <ast::Node::Ptr> Brace_list
%type <ast::Node::Ptr> Angle_list


%start input

%%

/*** structure ***/

input
  : %empty
  | input code
  ;

code
  : %empty
    { $$ = ast::CodeBlock::empty(); }
  | code line
    { $$ = $1.append($2); }
  ;

line
  : expr NL
    { $$ = $1; }
  | NL
    { $$ = ast::Expression::empty(); }
  | statement NL
    { $$ = $1; }
  | error
    { yy::errok(); }
  ;

block
  : INDENT code OUTDENT
    { $$ = ast::CodeBlock($2); }
  ;

/* Expressions */
statement
  : if
    { $$ = ast::Expression($1); }
  ;


expr
  /* atomic */
  : Identifier
    { $$ = rt::symbol[$1]; }
  | String_literal
    { $$ = ast::StringLiteral($1); }
  | Integer_literal
    { $$ = ast::IntegerLiteral($1); }
  | Float_literal
    { $$ = ast::FloatLiteral($1); }
  | '(' expr ')'
    { $$ = $2; }
  /* prefix */
  | "++" expr
    %prec PREINCREMENT
    { $$ = ast::ops::PreIncrement($2); }
  | "--" expr
    %prec PREDECREMENT
    { $$ = ast::ops::PreDecrement($2); }
  | "-" expr
    %prec UNARY_MINUS
    { $$ = ast::ops::PreDecrement($2); }
  | "^/" expr
    %prec SQUARE_ROOT
    { $$ = ast::ops::Root(2, $2); }
  /* postfix */
  | expr "++"
    %prec POSTINCREMENT
    { $$ = ast::ops::PostIncrement($1); }
  | expr "--"
    %prec POSTDECREMENT
    { $$ = ast::ops::PostDecrement($1); }
  /* binary */
  | expr "+" expr
    %prec ADD
    { $$ = ast::ops::Add($1, $3); }
  | expr "-" expr
    %prec SUB
    { $$ = ast::ops::Subtract($1, $3); }
  | expr "*" expr
    %prec MULT
    { $$ = ast::ops::Multiply($1, $3); }
  | expr "/" expr
    %prec DIV
    { $$ = ast::ops::Divide($1, $3); }
  | expr "//" expr
    %prec DIV
    { $$ = ast::ops::IntegerDivide($1, $3); }
  | expr "^/" expr
    %prec ROOT
    { $$ = ast::ops::Root($1, $3); }
  | expr "^" expr
    %prec POW
    { $$ = ast::ops::Power($1, $3); }
  | expr "=" expr
    %prec ASSIGN
    { $$ = ast::ops::Assign($1, $3); }
  | expr ":" expr
    %prec TYPE_ASSERT
    { $$ = ast::ops::AssertType($1, $3); }
  /* other */
  | lambda_expr
    { $$ = ast::asBase($1); }
  ;

lambda_body
  : expr
    { $$ = ast::LambdaBody($1); }
  | NL block
    { $$ = ast::ResultHavingCode($2); }
  ;


lambda_expr
  : Par_list "=>" lambda_body
  %prec LAMBDA
    { $$ = ast::Lambda(args=$1, expr=$3); }
  ;

/* control flow */
if
  : IF expr NL
      block
    if_follow_up
    { $$ = ast::IfStatement(condition=$2, then=$4); }
  ;

if_follow_up
  : %empty
    { $$ = ast::CodeBlock::empty(); }
  | ELIF expr NL
      block
    if_follow_up
    { $$ = ast::IfStatement( condition=$2
                           , then=$4
                           , else=$5
                           );
    }
  | ELSE NL
      block
    { $$ = $3; }
  ;

commalist_
  : expr
    { $$ = ast::CommaDelimitedList::fromFirst($1); }
  | commalist_ "," expr
    %prec LIST
    { $$ = $1.append($3); }
  ;

commalist
  : commalist_
    { $$ = ast::CommaDelimitedList($1); }
  ;

Par_list
  : '(' commalist ')'
    { $$ = $2; }
  ;

Brack_list
  : '[' commalist ']'
    { $$ = $2; }
  ;

Brace_list
  : '{' commalist '}'
    { $$ = $2; }
  ;

Angle_list
  : '<' commalist '>'
    { $$ = $2; }
  ;


%%


//void yy::parser::error(const syntax_error& err)
void yy::parser::error(const location_type& loc, const std::string& msg)
{
  std::cerr << loc <<":\t" << msg << std::endl;
}

/* Fluster Bison Grammar */

%require "3.4"

/*%define api.language "c++"*/
%skeleton "lalr1.cc"
%define api.token.constructor
%printer { yyo << $$; } <*>;
%define api.value.type variant

/* can switch to custom type here */
%define parse.assert

%{
#include <iostream>
#define DEBUG
%}

%code requires {
  #include <string>
  #include "ast/base.h"
  /*
  namespace yy {
    class Lexer;
  }
  */
}

%param { Driver& driver }

%locations
%define parse.trace
%define parse.error verbose
%define api.namespace {fluster}
%define api.location.file "location.gen.h"
%define api.parser.class {Parser}
%define api.prefix {}
%parse-param { yy::Lexer& lexer }

%code{
  #include "driver.h"
  #include "lexer.h"
  //#undef yylex
  //#define yylex lexer.yylex
}

/*%define api.token.prefix {TOK_}*/
/* tokens */
/* TODO: reorder by precendence */

/* control tokens */
%token      EOF         0       "EOF"
%token      INDENT
%token      OUTDENT
%token      NL                  "\n"

/* grouping */
%left       SEQ_EXEC                /* a; b */
            LIST                    /* a, b, c */
;

/* assignment */
%right      ASSIGN                  /* value assignment */

/* anonymous functions */
%right      LAMBDA

/* type assertion */
%left       TYPE_ASSERT             /* a: T */

/* arithmetic */
%left       DISJUNCT                /* | */
%left       CONJUNCT                /* & */
%left       IMPLY                   /* -> */
%left       EQ_RELATIONAL           /* ==, !=, #=, !#= */
%nonassoc   NON_EQ_RELATIONAL       /* <=>, <, <=, >=, > */
%left       LSHIFT
            RSHIFT
;
%left       ADD
            SUB
;
%left       MULT                    /* * */
            DIV                     /* / // */
            MOD                     /* % mod // */
;
%left       POW                     /* a ^ b */
            ROOT                    /* a ^/ b */
;

/* comparision/relational tokens */
%nonassoc   LANGLE              "<"         /* less than */
            LANGLE_EQ           "<="        /* less than or equal to */
            EQ_EQ               "=="        /* value comparison */
            EXCLAIM_EQ          "!="        /* complement of value comparison */
            HASH_EQ             "#="        /* identity comparision */
            LANGLE_EQ_RANGLE    "<=>"       /* ternary comparison */
            RANGLE_EQ           ">="        /* greater than or equal to */
            RANGLE              ">"         /* greater than */
;

/* prefix operations */
%right      COMPLEMENT          /* ~a */
            NEGATE              /* -a */
            TYPE_MUT            /* !T */
            TYPE_ARRAY          /* [N]T */
            TYPE_PTR            /* *T */
            TYPE_REF            /* &T */
            IS_OP               /* is T */
            HAS_OP              /* has T */
            UNARY_MINUS         /* -a */
            SQUARE_ROOT         /* ^/a */
            PREINCREMENT        /* ++a */
            PREDECREMENT        /* --a */
            SPREAD              /* ...a */
            CLONEOF
            TYPEOF
            IMPORT
            COMPOSE             /* @a */
;

/* postfix operations */
%left
            POSTINCREMENT       /* a++ */
            POSTDECREMENT       /* a-- */
            INVOKE              /* a() */
            SUBSCRIPT           /* a[] */
            PARAMETRIZE         /* a<> */
            ACCESS              /* a._ */
;

%token      IN                  "in"        /* containment expression */
%token      CONTAINS            "contains"  /* containment expression */
%token      MOD                 "mod"       /* modular division */
%token      IF                  "if"        /* start if statement */
%token      ELSE                "else"      /* start else statement */
%token      ELIF                "elif"      /* start else if statement */
%token      FOR                 "for"       /* start for loop */
%token      WHILE               "while"     /* start while loop */
%token      UNTIL               "until"     /* start until loop */
%token      REPEAT              "repeat"    /* start infinite loop */
%token      TRY                 "try"       /* attempt expression */
%token      RETRY               "retry"     /* retry attempted expression */
%token      HANDLE              "handle"    /* declare exception handling case */
%token      RAISE               "raise"     /* raise an exception case */
%token      WITH                "with"      /* declare context */
%token      STRUCT              "struct"    /* declare structure */
%token      CLASS               "class"     /* declare dynamic-type reference structure */
%token      TYPEOF              "typeof"    /* get type of expression */
%token      CLONEOF             "cloneof"   /* get clone of type */
%token      IMPORT              "import"    /* import a path */
/*ast::Identifier*/
%token <ast::Identifier> Identifier
%token <data::NaturalNum> Integer_literal
%token <data::RationalNum> Float_literal
%token <data::ByteArray> Bytes_literal
%token <data::BitArray> Bits_literal
%token <data::String> String_literal

%type <ast::Node::Ptr> expr
%type <ast::Node::Ptr> statement
%type <ast::Node::Ptr> lambda_body
%type <ast::Node::Ptr> code
%type <ast::Node::Ptr> block
%type <ast::Node::Ptr> elifs
%type <ast::Node::Ptr> if
%type <ast::Node::Ptr> line
%type <ast::Node::Ptr> lambda_expr
%type <ast::Node::Ptr> commalist_
%type <ast::Node::Ptr> commalist
%type <ast::Node::Ptr> Par_list
%type <ast::Node::Ptr> Brack_list
%type <ast::Node::Ptr> Brace_list
%type <ast::Node::Ptr> Angle_list


%start input

%%
/**************************
 Grammer Rules and Actions
 **************************/
/* ops */
/* %left PLUS DASH               /*|   + -       |*/
/* %left STAR FSLASH TWOFSLASH   /*|   * / //    |*/
/* %right CARET CARETFSLASH      /*|   ^ ^/      |*/
/* %precedence UNARY             /*|   ^ ^/ -    |*/
/*** structure ***/
input
  : %empty
  | input code
  ;

code
  : %empty
    { $$ = ast::CodeBlock::empty(); }
  | code line
    { $$ = $1.append($2); }
  ;

line
  : expr NL
    { $$ = $1; }
  | NL
    { $$ = ast::Expression::empty(); }
  | statement NL
    { $$ = $1; }
  | error
    { yy::errok(); }
  ;

block
  : INDENT code OUTDENT
    { $$ = ast::CodeBlock($2); }
  ;

/* Expressions */
statement
  : if
    { $$ = ast::Expression($1); }
  ;


expr
  /* atomic */
  : Identifier
    { $$ = rt::symbol[$1]; }
  | String_literal
    { $$ = ast::StringLiteral($1); }
  | Integer_literal
    { $$ = ast::IntegerLiteral($1); }
  | Float_literal
    { $$ = ast::FloatLiteral($1); }
  | '(' expr ')'
    { $$ = $2; }
  /* prefix */
  | "++" expr
    %prec PREINCREMENT
    { $$ = ast::ops::PreIncrement($2); }
  | "--" expr
    %prec PREDECREMENT
    { $$ = ast::ops::PreDecrement($2); }
  | "-" expr
    %prec UNARY_MINUS
    { $$ = ast::ops::PreDecrement($2); }
  | "^/" expr
    %prec SQUARE_ROOT
    { $$ = ast::ops::Root(2, $2); }
  /* postfix */
  | expr "++"
    %prec POSTINCREMENT
    { $$ = ast::ops::PostIncrement($1); }
  | expr "--"
    %prec POSTDECREMENT
    { $$ = ast::ops::PostDecrement($1); }
  /* binary */
  | expr "+" expr
    %prec ADD
    { $$ = ast::ops::Add($1, $3); }
  | expr "-" expr
    %prec SUB
    { $$ = ast::ops::Subtract($1, $3); }
  | expr "*" expr
    %prec MULT
    { $$ = ast::ops::Multiply($1, $3); }
  | expr "/" expr
    %prec DIV
    { $$ = ast::ops::Divide($1, $3); }
  | expr "//" expr
    %prec DIV
    { $$ = ast::ops::IntegerDivide($1, $3); }
  | expr "^/" expr
    %prec ROOT
    { $$ = ast::ops::Root($1, $3); }
  | expr "^" expr
    %prec POW
    { $$ = ast::ops::Power($1, $3); }
  | expr "=" expr
    %prec ASSIGN
    { $$ = ast::ops::Assign($1, $3); }
  | expr ":" expr
    %prec TYPE_ASSERT
    { $$ = ast::ops::AssertType($1, $3); }
  /* other */
  | lambda_expr
    { $$ = ast::asBase($1); }
  ;

lambda_body
  : expr
    { $$ = ast::LambdaBody($1); }
  | NL block
    { $$ = ast::ResultHavingCode($2); }
  ;


lambda_expr
  : Par_list "=>" lambda_body
  %prec LAMBDA
    { $$ = ast::Lambda(args=$1, expr=$3); }
  ;

/* control flow */
if
  : IF expr NL
      block
    elifs
    { $$ = ast::IfStatement(condition=$2, then=$4); }
  | IF expr NL
      block
    elifs
    ELSE
      block
    { $$ = ast::IfStatement(condition=$2,
                            then=$4,
                            else_=ast::CodeBlock($5, $7)
      );
    }
  ;

elifs
  : %empty
    { $$ = ast::CodeBlock::empty(); }
  | elifs ELIF expr NL block
    { $$ = $1.append(
                ast::IfStatement(condition=$3,
                                 then=$5
      ));
    }
  ;

commalist_
  : expr
    { $$ = ast::CommaDelimitedList::fromFirst($1); }
  | commalist_ "," expr
    %prec LIST
    { $$ = $1.append($3); }
  ;

commalist
  : commalist_
    { $$ = ast::CommaDelimitedList($1); }
  ;

Par_list
  : '(' commalist ')'
    { $$ = $2; }
  ;

Brack_list
  : '[' commalist ']'
    { $$ = $2; }
  ;

Brace_list
  : '{' commalist '}'
    { $$ = $2; }
  ;

Angle_list
  : '<' commalist '>'
    { $$ = $2; }
  ;


%%


// TODO: define elsewhere
using location_type = long;

//void yy::parser::error(const syntax_error& err)

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  std::cerr << loc <<":\t" << msg << std::endl;
}

/*
int main(void)
{
  Lexer.lex();
  return yy::parse();
}
*/

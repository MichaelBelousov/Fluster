/* Fluster Bison Grammar */

%require "3.4"
%language "c++" /* generates C++ */

%define api.namespace {yy}
%define api.parser.class {Parser}
%define api.value.type variant
%define api.token.constructor

%define parse.trace
%define parse.error verbose
%define parse.assert

%locations
%define api.location.file "location.gen.h"
%defines "parser.gen.h"
%output "parser.gen.cpp"
%printer { yyo << $$; } <*>;

%parse-param { yy::Lexer& lexer }  //construct parser object with lexer

/*%param { Driver& driver }*/

/* code in this block goes in parser.gen.h */
%code requires {
  //#include "driver.h"
  #include "ast/ast.h"
  //XXX: remove this so inclusion doesn't use the namespace!
  //namespace ast = fluster::ast;
  namespace yy {
    class Lexer;  // reflex --namespace=yy --lexer=Lexer --lex=yylex
  };
  #undef yylex  //unlink the global yylex
  #define yylex lexer.lex  //within bison's parse invoke lexer.yylex()
}

%code top {
  #include <iostream>
  #include <string>
  #include <memory>
  #include "atoms/types.h"
}

%code {
  #include <utility>
  //#include "driver.h"
  #include "lexer.gen.h"
  #include "location.gen.h"
  using namespace fluster;

  template<typename T>
  fluster::ast::Expr::Ptr asExprPtr(T&& t) {
    return std::static_pointer_cast<fluster::ast::Expr>(
      std::forward<T>(t)
    );
  }

  template<typename T>
  fluster::ast::Node::Ptr asNodePtr(T&& t) {
    return std::static_pointer_cast<fluster::ast::Node>(
      std::forward<T>(t)
    );
  }

}

/*
%code {
skipToNextLine()
  {
    while(Lexer.lex() != yy::Parser::make_S_OUTDENT);
  }
}
*/

/*** Precedence Markers ***/

/* grouping */
%left       SEQ_EXEC        /* a; b */
            LIST            /* a, b, c */
;

/* assignment */
%right      ASSIGN          /* assignment */

/* anonymous functions */
%right      LAMBDA          /* a => a, (a,b) => a+b */

/* type assertion */
%left       TYPE_ASSERT     /* a: T */

/* arithmetic */
%left       DISJUNCT        /* | */
%left       CONJUNCT        /* & */
%left       IMPLY           /* -> */
%left       EQUALITY        /* ==, !=, #=, !#= */
%nonassoc   SPACESHIP       /* <=> */
%nonassoc   RELATIONAL      /* <, <=, >=, > */
%left       IN              /* a in b */
%left       LSHIFT RSHIFT;  /* <<, >> */
%left       ADD     /* + */
            SUB     /* - */
;
%left       MULT    /* * */
            DIV     /* / // */
            MOD     /* % mod // */
;
%left       POW     /* a ^ b */
            ROOT    /* a ^/ b */
;

/* prefix operations */
%right      COMPLEMENT      /* ~a */
            NEGATE          /* -a */
            TYPE_MUT        /* !T */
            TYPE_ARRAY      /* [N]T */
            TYPE_PTR        /* *T */
            TYPE_REF        /* &T */
            TYPE_OPT        /* ?T */
            IS              /* is T */
            HAS             /* has T */
            SQUARE_ROOT     /* ^/a */
            PREINCREMENT    /* ++a */
            PREDECREMENT    /* --a */
            SPREAD          /* ...a */
            CLONEOF         /* cloneof a */
            TYPEOF          /* typeof a */
            IMPORT          /* import '' */
            COMPOSE         /* @a */
;

/* postfix operations */
%left
            POSTINCREMENT   /* a++ */
            POSTDECREMENT   /* a-- */
            INVOKE          /* a() */
            SUBSCRIPT       /* a[] */
            PARAMETRIZE     /* a<> */
            ACCESS          /* a._ */
;

%token      KW_IF      /* start if statement */
%token      KW_ELSE    /* start else statement */
%token      KW_ELIF    /* start else if statement */
%token      KW_FOR     /* start for loop */
%token      KW_WHILE   /* start while loop */
%token      KW_UNTIL   /* start until loop */
%token      KW_REPEAT  /* start infinite loop */
%token      KW_CASE    /* declare dynamic-type reference structure */
%token      KW_TRY     /* attempt expression */
%token      KW_RETRY   /* retry attempted expression */
%token      KW_HANDLE  /* declare exception handling case */
%token      KW_RAISE   /* raise an exception case */
%token      KW_WITH    /* declare context */
%token      KW_STRUCT  /* declare structure */
%token      KW_CLASS   /* declare dynamic-type reference structure */

/*** Lexer Symbols ***/

    /* the S_ prefix indicates lexer symbols */
    /* TODO: drop prefix and make precendence UpperCamelCase */
%token      S_END 0
%token      S_INDENT S_OUTDENT S_NL
            /* grouping */
            S_SEMICOLON S_COMMA
            /* assignment */
            S_EQ S_PLUS_EQ S_DASH_EQ S_STAR_EQ S_FSLASH_EQ S_FSLASH_FSLASH_EQ
            S_CARET_FSLASH_EQ S_CARET_EQ S_AMPERSAND_EQ S_PIPE_EQ S_TILDE_EQ
            S_LANGLE_LANGLE_EQ S_RANGLE_RANGLE_EQ S_DASH_RANGLE_EQ
            /* anonymous functions */
            S_EQ_RANGLE
            /* type assertion */
            S_COLON
            /* membership */
            S_IN
            /* logical */
            S_PIPE S_AMPERSAND S_DASH_RANGLE
            /* equality */
            S_EQ_EQ S_EXCLAIM_EQ S_HASH_EQ S_EXCLAIM_HASH_EQ
            /* spaceship */
            S_LANGLE_EQ_RANGLE
            /* relational */
            S_LANGLE S_LANGLE_EQ S_RANGLE_EQ S_RANGLE
            /* shift */
            S_LANGLE_LANGLE S_RANGLE_RANGLE
            /* addition/subtraction */
            S_PLUS S_DASH
            /* multiplication */
            S_STAR
            /* division */
            S_FSLASH S_FSLASH_FSLASH
            /* modular division */
            S_PERCENT S_MOD
            /* power */
            S_CARET
            /* root */
            S_CARET_FSLASH
            /* prefix */
            S_DASH_DASH S_PLUS_PLUS
            S_TILDE S_NEGATE S_EXCLAIM
            S_IS S_HAS S_QUES
            S_DOT_DOT_DOT KW_CLONEOF KW_TYPEOF KW_IMPORT S_AT
            /* postfix */
            S_DOT
            /* other */
            S_LPAR S_RPAR S_LBRACK S_RBRACK S_LBRACE S_RBRACE
;

/*** Tagged Types ***/

%token <fluster::ast::Identifier::Ptr> Identifier
%token <fluster::ast::lits::Integer::Ptr> IntegerLiteral
%token <fluster::ast::lits::Float::Ptr> FloatLiteral
%token <fluster::ast::lits::Bytes> BytesLiteral
%token <fluster::ast::lits::Bits> BitsLiteral
%token <fluster::ast::lits::String::Ptr> StringLiteral

%type <fluster::ast::Expr::Ptr> expr
%type <fluster::ast::Node::Ptr> statement
%type <fluster::ast::Block::Ptr> code
%type <fluster::ast::Block::Ptr> block
%type <fluster::ast::IfStatement::Ptr> if
%type <fluster::ast::Node::Ptr> if_follow_up
%type <fluster::ast::Node::Ptr> line
/*
%type <fluster::ast::Node::Ptr> lambda_expr
%type <fluster::ast::Node::Ptr> lambda_body
%type <fluster::ast::Node::Ptr> commalist_
%type <fluster::ast::Node::Ptr> commalist
%type <fluster::ast::Node::Ptr> Par_list
%type <fluster::ast::Node::Ptr> Brack_list
%type <fluster::ast::Node::Ptr> Brace_list
%type <fluster::ast::Node::Ptr> Angle_list
*/

%start input


%%


/*** structure ***/

input
  : %empty
  | input code
  ;

code
  : %empty
    { $$ = fluster::ast::Block::empty(); }
  | code line
    { $1->append($2); }
  ;

line
  : expr S_NL
    { $$ = $1; }
  | S_NL
    { $$ = fluster::ast::Block::empty(); }  /* TODO: handle empty statements better? */
  | statement S_NL
    { $$ = $1; }
  | error S_NL
    { yyerrok; }
  ;

block
  : S_INDENT code S_OUTDENT
    { $$ = fluster::ast::Block::Ptr($2); }
  ;

/* Expressions */
statement
  : if
    { $$ = asNodePtr($1); }
  ;

expr
  /* atomic */
  : Identifier
    { $$ = asExprPtr($1); }

  | StringLiteral
    { $$ = asExprPtr($1); }

  | IntegerLiteral
    { $$ = asExprPtr($1); }

  | FloatLiteral
    { $$ = asExprPtr($1); }

  | S_LPAR expr S_RPAR
    { $$ = $2; }

  /* prefix */
  | S_PLUS_PLUS expr
    %prec PREINCREMENT
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::PreIncrement>($2)
      );
    }

  | S_DASH_DASH expr
    %prec PREDECREMENT
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::PreDecrement>($2)
      );
    }

  | S_DASH expr
    %prec NEGATE
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::Negate>($2)
      );
    }

  | S_CARET_FSLASH expr
    %prec SQUARE_ROOT
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::Root>(
              std::make_shared<fluster::ast::lits::Integer>(2),
              $2
          )
      );
    }

  /* postfix */
  | expr S_PLUS_PLUS
    %prec POSTINCREMENT
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::PostIncrement>($1)
      );
    }

  | expr S_DASH_DASH
    %prec POSTDECREMENT
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::PostDecrement>($1)
      );
    }

  /* binary */
  | expr S_PLUS expr
    %prec ADD
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::Add>($1, $3)
      );
    }

  | expr S_DASH expr
    %prec SUB
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::Subtract>($1, $3)
      );
    }

  | expr S_STAR expr
    %prec MULT
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::Multiply>($1, $3)
      );
    }

  | expr S_FSLASH expr
    %prec DIV
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::Divide>($1, $3)
      );
    }

  | expr S_FSLASH_FSLASH expr
    %prec DIV
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::IntDivide>($1, $3)
      );
    }

  | expr S_CARET_FSLASH expr
    %prec ROOT
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::Root>($1, $3)
      ); 
    }

  | expr S_CARET expr
    %prec POW
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::Power>($1, $3)
      );
    }

  | expr S_EQ expr
    %prec ASSIGN
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::Assign>($1, $3)
      );
    }

  | expr S_COLON expr
    %prec TYPE_ASSERT
    { $$ = asExprPtr(
          std::make_shared<fluster::ast::ops::AssertType>($1, $3)
      );
    }

  /* other */
  /*
  | lambda_expr
    { $$ = asExprPtr($1); }
  */
  ;

/*
lambda_body
  : expr
    { $$ = fluster::ast::LambdaBody::Ptr($1); }
  | S_NL block
    { $$ = fluster::ast::ResultHavingCode::Ptr($2); }
  ;


lambda_expr
  : Par_list S_EQ_RANGLE lambda_body
  %prec LAMBDA
    { $$ = fluster::ast::Lambda::Ptr(args=$1, expr=$3); }
  ;
*/


/* control flow */
if
  : KW_IF expr S_NL
      block
    if_follow_up
    { $$ = std::make_shared<fluster::ast::IfStatement>($2, $4); }
  ;


if_follow_up

  : %empty
    { $$ = fluster::ast::IfStatement::empty(); }

  | KW_ELIF expr S_NL
      block
    if_follow_up
    { $$ = std::make_shared<fluster::ast::IfStatement>($2, $4, $5); }

  | KW_ELSE S_NL
      block
    { $$ = $3; }
  ;

/*
commalist_
  : expr
    { $$ = fluster::ast::CommaDelimitedList::fromFirst($1); }
  | commalist_ S_COMMA expr
    %prec LIST
    { $$ = $1->append($3); }
  ;

commalist
  : commalist_
  ;

Par_list
  : '(' commalist ')'
    { $$ = $2; }
  ;

Brack_list
  : '[' commalist ']'
    { $$ = $2; }
  ;

Brace_list
  : '{' commalist '}'
    { $$ = $2; }
  ;

Angle_list
  : '<' commalist '>'
    { $$ = $2; }
  ;
*/


%%


//void yy::Parser::error(const syntax_error& err)
void yy::Parser::error(const location_type& loc, const std::string& msg)
{
  std::cerr << loc << ":\t" << msg << std::endl;
}


/* Fluster Bison Grammar */

/***********
 Definitions
 ***********/

/* options */

%skeleton "lalr1.cc"
%require "3.0"

/* C++ */

%define api.token.constructor
/* can switch to custom type here */
%define api.value.type variant
%define parse.assert

%{
#include <iostream>
#define DEBUG
%}

%code requires {

#include <string>
#include "ast/base.h"
class fluster::Driver;
/*
namespace yy {
  class Lexer;
}
*/

}

%param { Driver& driver }
%locations
%define parse.trace
%define parse.error verbose
%define api.namespace {fluster::}
/*%define api.location.file "lexer.h"*/
%define api.parser.class "Parser"
%define api.prefix {}

%define api.pure full

%parse-param { yy::Lexer& lexer }

%code{

#include "driver.h"
#include "lexer.h"
#undef yylex
#define yylex lexer.yylex

}


/* tokens */

/* TODO: reorder by precendence */

%define api.token.prefix {TOK_}

%token      END     0  "end of file"
%token INDENT OUTDENT 
%token NEWLINE "\n"

/*** binary operators ***/
%right      EQ                  "="         /* value assignment */
%token      LANGLE              "<"         /* less than */
%token      LANGLE_EQ           "<="        /* less than or equal to */
%left       EQ_EQ               "=="        /* value comparison */
%left       HASH_EQ             "#="        /* identity comparision */
%left       LANGLE_EQ_RANGLE    "<=>"       /* ternary comparison */
%nonassoc   TILDE               "~"         /* complement */
%nonassoc   TILDE_TILDE         "~~"        /* unknown */
%token      EXCLAIM             "!"         /* mutable type */
%right      EXCLAIM_EQ          "!="        /* complement of value comparison */
%left       RANGLE_EQ           ">="        /* greater than or equal to */
%left       RANGLE              ">"         /* greater than */
%left       PLUS                "+"         /* addition, structural type inheritance */
%left       DASH                "-"         /* subtraction */
%left       STAR                "*"         /* multiplication */
%left       FSLASH              "/"         /* division */
%left       FSLASH_FSLASH       "//"        /* integer division (yields tuple of result and remainder) */
%left       PERCENT             "%"         /* modular division? */
%left       CARET               "^"         /* bitwise xor, power */
%left       CARET_FSLASH        "^/"        /* binary root, unary square root */
%nonassoc   HAS                 "has"       /* composition/implementation, type implementors qualifier */
%nonassoc   IS                  "is"        /* inheritance, type inheritance qualifier */
%left       AMPERSAND           "&"         /* logical and, bitwise and, set intersection, structural type intersection */
%left       PIPE                "|"         /* logical or, bitwise or, set union, structural type union */
%left       RANGLE_RANGLE       ">>"        /* bitwise shift right */
%left       LANGLE_LANGLE       "<<"        /* bitwise shift left */
%left       DASH_RANGLE         "->"        /* logical implication, case indication */
%right      PLUS_EQ             "+="        /* addition assignment */
%right      DASH_EQ             "-="        /* subtraction assignment */
%right      STAR_EQ             "*="        /* multiplication assignment */
%right      FSLASH_EQ           "/="        /* division assignment */
%right      FSLASH_FSLASH_EQ    "//="       /* integer division assignment (discards remainder) */
%right      CARET_FSLASH_EQ     "^/="       /* root assignment */
%right      CARET_EQ            "^="        /* bitwise xor assignment, power assignment */
%right      AMPERSAND_EQ        "&="        /* ampersand assignment */
%right      PIPE_EQ             "|="        /* pipe assignment */
%right      TILDE_EQ            "~="        /* complement assignment */
%right      RANGLE_RANGLE_EQ    ">>="       /* right-shift assignment */
%right      LANGLE_LANGLE_EQ    "<<="       /* left-shift assignment */
%left       DASH_RANGLE_EQ      "->="       /* implication assignment */
%nonassoc   PLUS_PLUS           "++"        /* increment */
%nonassoc   DASH_DASH           "--"        /* decrement */
%nonassoc   DOLLAR              "$"         /* unknown */
/* %left     LANGLE_DASH         "<-"          CONFLICT since '-' is unary" */
%nonassoc   DOT                 "."         /* hierarchical/structural access */
%nonassoc   DOT_DOT             ".."        /* slice range opening, pack expansion, pack declaration */
%nonassoc   DOT_DOT_DOT         "..."       /* empty */
%nonassoc   LBRACK              "["         /* start access expression, start list literal */
%nonassoc   RBRACK              "]"         /* end access expression, end list literal */
%nonassoc   LBRACE              "{"         /* start set or object type/value expression */
%nonassoc   RBRACE              "}"         /* end set or object type/value expression */
%nonassoc   LPAR                "("         /* start separate expression, start tuple literal, start invoke */
%nonassoc   RPAR                ")"         /* end separate expression, end tuple literal, end invoke */
%left       COMMA               ","         /* separate values */
%right      EQ_RANGLE           "=>"        /* anonymous function */
%right      COLON               ":"         /* type assertion */
%right      SEMICOLON           ";"         /* chain and discard expressions */
%nonassoc   AT                  "@"         /* decorator invocation */
%nonassoc   QUES                "?"         /* optional type */
%right      IN                  "in"        /* containment expression */
%right      CONTAINS            "contains"  /* containment expression */
%left       MOD                 "mod"       /* modular division */
%nonassoc   IF                  "if"        /* start if statement */
%nonassoc   ELSE                "else"      /* start else statement */
%nonassoc   ELIF                "elif"      /* start else if statement */
%nonassoc   FOR                 "for"       /* start for loop */
%nonassoc   WHILE               "while"     /* start while loop */
%nonassoc   UNTIL               "until"     /* start until loop */
%nonassoc   REPEAT              "repeat"    /* start infinite loop */
%nonassoc   TRY                 "try"       /* attempt expression */
%nonassoc   RETRY               "retry"     /* retry attempted expression */
%nonassoc   HANDLE              "handle"    /* declare exception handling case */
%nonassoc   RAISE               "raise"     /* raise an exception case */
%nonassoc   WITH                "with"      /* declare context */
%nonassoc   STRUCT              "struct"    /* declare structure */
%nonassoc   CLASS               "class"     /* declare dynamic-type reference structure */
%nonassoc   TYPEOF              "typeof"    /* get type of expression */
%nonassoc   CLONEOF             "cloneof"   /* get clone of type */
%nonassoc   IMPORT              "import"    /* import a path */


/*ast::Identifier*/
%token <fluster::ast::Identifier> Identifier
%token <fluster::data::NaturalNum> Integer_literal
%token <fluster::data::RationalNum> Float_literal
%token <fluster::data::ByteArray> Bytes_literal
%token <fluster::data::BitArray> Bits_literal
%token <fluster::data::String> String_literal

/*%type <fluster::ast::Node> Expr */
%type <fluster::ast::Expression> Expr
%type <fluster::ast::Statement> Statement

%printer { yyo << $$; } <*>;

%start input

%%

/**************************
 Grammer Rules and Actions
 **************************/


/* ops */
/* %left PLUS DASH               /*|   + -       |*/
/* %left STAR FSLASH TWOFSLASH   /*|   * / //    |*/
/* %right CARET CARETFSLASH      /*|   ^ ^/      |*/
/* %precedence UNARY             /*|   ^ ^/ -    |*/

/*** structure ***/

input
  : %empty
  | input code
  ;

code
  : %empty
  | code line
  ;

line
  : Expr
  | '\n'
  | statement
  | error {
      yy::errok();
    }
  ;

block
  : INDENT code OUTDENT
  ;

/* Expressions */

type_expr: Expr;

statement
  : var_decl
  ;

Expr
  : Expr
  | Identifier
    { $$ = fluster::rt::symbol[$1]; }
  | String_literal 
    { $$ = fluster::ast::StringLiteral($1); }
  | Integer_literal
    { $$ = fluster::ast::IntegerLiteral($1); }
  | Float_literal
    { $$ = fluster::ast::FloatLiteral($1); }
  | LPAR Expr RPAR
    { $$ = $2; }
  /* unary postfix */
  | Expr PLUS_PLUS
    { $$ = fluster::ast::ops::PostIncrement($1); }
  | Expr DASH_DASH
    { $$ = fluster::ast::ops::PostDecrement($1); }
  /* unary prefix */
  | PLUS_PLUS Expr
    { $$ = fluster::ast::ops::PreIncrement($2); }
  | DASH_DASH Expr
    { $$ = fluster::ast::ops::PreDecrement($2); }
  /* binary */
  | Expr PLUS Expr
    { $$ = fluster::ast::ops::Add($1, $3); }
  | Expr DASH Expr
    { $$ = fluster::ast::ops::Subtract($1, $3); }
  | Expr STAR Expr
    { $$ = fluster::ast::ops::Multiply($1, $3); }
  | Expr FSLASH Expr
    { $$ = fluster::ast::ops::Divide($1, $3); }
  | Expr FSLASH_FSLASH Expr
    { $$ = fluster::ast::ops::IntegerDivision($1, $3); }
  ;

/* control flow */

if
  : IF Expr NEWLINE
      block
    elifs
  | IF Expr NEWLINE
      block
    elifs
    ELSE
      block
  ;

elifs
  : %empty
  | elifs ELIF Expr NEWLINE block
  ;

var_decl
  : var_decl_lhs EQ Expr
  ;

var_decl_lhs
  : Identifier
  | Identifier COLON type_expr
  ;

/*
| exp PLUS exp                
| exp DASH exp              
| DASH exp %prec UNARY     
| exp STAR exp            
| exp FSLASH exp         
| exp TWOFSLASH exp     
| exp CARET exp        
| CARET exp %prec UNARY
| exp CARETFSLASH exp
| CARETFSLASH exp %prec UNARY
| '(' exp ')'
| lambda
;
*/

/*
lambda: 
  caparglist parlist EQRANGLE exp
  ;
*/

commalist
  : %empty
  | Expr
  | commalist COMMA Expr
  ;

parlist:    LPAR   commalist RPAR
/*
//not used yet
bracklist:  LBRACK commalist RBRACK
bracelist:  LBRACE commalist RBRACE
*/
anglelist:  LANGLE commalist RANGLE

%%

/****************
 Additional Code
 ****************/

using location_type = long;

//void yy::parser::error(const syntax_error& err)
void yy::parser::error(const location_type& loc, const std::string& msg)
{
  std::cerr << loc <<":\t" << msg << std::endl;
}

int main(void)
{
  Lexer.lex();
  return yy::parse();
}



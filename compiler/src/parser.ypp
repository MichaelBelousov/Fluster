
/* Fluster Bison Grammar */

/***********
 Definitions
 ***********/

/* options */

%skeleton "lalr1.cc"
%require "3.0"

/* C++ */

%define api.token.constructor
%define api.value.type.variant
%define parse.assert

%{
  #include <iostream>
  #define DEBUG
%}

%code requires {
  #include <string>
  class Fluster::Driver;
  /*
  namespace yy {
    class Lexer;
  }
  */
}

%param { Driver& driver }
%locations
%define parse.trace
%define parse.error verbose

%parse-param { yy::Lexer& lexer }

%code{

#include "driver.h"
#include "lexer.h"
#undef yylex
#define yylex lexer.yylex

}


/* tokens */

%define api.token.prefix {TOK_}
%token
    END                 0           "end of file"
    EQ                  "="         /* value assignment */
    LANGLE              "<"         /* less than */
    LANGLE_EQ           "<="        /* less than or equal to */
    EQ_EQ               "=="        /* value comparison */
    HASH_EQ             "#="        /* identity comparision */
    LANGLE_EQ_RANGLE    "<=>"       /* ternary comparison */
    TILDE               "~"         /* complement */
    TILDE_TILDE         "~~"        /* unknown */
    EXCLAIM             "!"         /* mutable type */
    EXCLAIM_EQ          "!="        /* complement of value comparison */
    RANGLE_EQ           ">="        /* greater than or equal to */
    RANGLE              ">"         /* greater than */
    PLUS                "+"         /* addition, structural type inheritance */
    DASH                "-"         /* subtraction */
    STAR                "*"         /* multiplication */
    FSLASH              "/"         /* division */
    FSLASH_FSLASH       "//"        /* integer division (yields tuple of result and remainder) */
    PERCENT             "%"         /* modular division? */
    CARET               "^"         /* bitwise xor, power */
    CARET_FSLASH        "^/"        /* root */
    HAS                 "has"       /* composition/implementation, type implementors qualifier */
    IS                  "is"        /* inheritance, type inheritance qualifier */
    AMPERSAND           "&"         /* logical and, bitwise and, set intersection, structural type intersection */
    PIPE                "|"         /* logical or, bitwise or, set union, structural type union */
    RANGLE_RANGLE       ">>"        /* bitwise shift right */
    LANGLE_LANGLE       "<<"        /* bitwise shift left */
    DASH_RANGLE         "->"        /* logical implication, case indication */
    PLUS_EQ             "+="        /* addition assignment */
    DASH_EQ             "-="        /* subtraction assignment */
    STAR_EQ             "*="        /* multiplication assignment */
    FSLASH_EQ           "/="        /* division assignment */
    FSLASH_FSLASH_EQ    "//="       /* integer division assignment (discards remainder) */
    CARET_FSLASH_EQ     "^/="       /* root assignment */
    CARET_EQ            "^="        /* bitwise xor assignment, power assignment */
    AMPERSAND_EQ        "&="        /* ampersand assignment */
    PIPE_EQ             "|="        /* pipe assignment */
    TILDE_EQ            "~="        /* complement assignment */
    RANGLE_RANGLE_EQ    ">>="       /* right-shift assignment */
    LANGLE_LANGLE_EQ    "<<="       /* left-shift assignment */
    DASH_RANGLE_EQ      "->="       /* implication assignment */
    DOLLAR              "$"         /* unknown */
/*  LANGLE_DASH         "<-"        /* CONFLICT since - is unary" * */
    DOT                 "."         /* structural access */
    DOT_DOT             ".."        /* slice range opening, pack expansion, pack declaration */
    DOT_DOT_DOT         "..."       /* empty */
    LBRACK              "["         /* start access expression, start list literal */
    RBRACK              "]"         /* end access expression, end list literal */
    LBRACE              "{"         /* start set or object type/value expression */
    RBRACE              "}"         /* end set or object type/value expressio */
    LPAR                "("         /* start separate expression, start tuple literal */
    RPAR                ")"         /* end separate expression, end tuple literal */
    COMMA               ","         /* separate values */
    EQ_RANGLE           "=>"        /* anonymous function */
    COLON               ":"         /* type assertion */
    SEMICOLON           ";"         /* chain and discard expressions */
    AT                  "@"         /* decorator invocation */
    QUES                "?"         /* optional type */
    IN                  "in"        /* containment expression */
    CONTAINS            "contains"  /* containment expression */
    MOD                 "mod"       /* modular division */
    IF                  "if"        /* start if statement */
    ELSE                "else"      /* start else statement */
    ELIF                "elif"      /* start else if statement */
    FOR                 "for"       /* start for loop */
    WHILE               "while"     /* start while loop */
    UNTIL               "until"     /* start until loop */
    REPEAT              "repeat"    /* start infinite loop */
    TRY                 "try"       /* attempt expression */
    RETRY               "retry"     /* retry attempted expression */
    HANDLE              "handle"    /* declare exception handling case */
    RAISE               "raise"     /* raise an exception case */
    WITH                "with"      /* declare context */
    STRUCT              "struct"    /* declare structure */
    CLASS               "class"     /* declare dynamic-type reference structure */
    TYPEOF              "typeof"    /* get type of expression */
    CLONEOF             "cloneof"   /* get clone of type */
    IMPORT              "import"    /* import a path */
;

%token <Fluster::data::Identifier> IDENTIFIER "identifier"
%token <Fluster::data::NaturalNum> INTEGER_LIT "integer_lit"
%token <Fluster::data::RationalNum> FLOAT_LIT "float_lit"
%token <Fluster::data::ByteArray> BYTES_LIT "bytes_lit"
%token <Fluster::data::BitArray> BITS_LIT "bits_lit"
%type <Fluster::ast::Expression> expr

%printer { yyo << $$; } <*>;

%%

/**************************
 Grammer Rules and Actions
 **************************/

%start input

/* ops */
/* %left PLUS DASH               /*|   + -       |*/
/* %left STAR FSLASH TWOFSLASH   /*|   * / //    |*/
/* %right CARET CARETFSLASH      /*|   ^ ^/      |*/
/* %precedence UNARY             /*|   ^ ^/ -    |*/

input:
  %empty
  | code input
;

code:
  '\n' 
  | any
  | error '\n'    
    { yyerrok; } 
;

any:
  lit
| class
| struct_decl
| func_decl;

lit:
  INTEGER
| FLOATING
| BYTES
| BITS
;

/*
| exp PLUS exp                
| exp DASH exp              
| DASH exp %prec UNARY     
| exp STAR exp            
| exp FSLASH exp         
| exp TWOFSLASH exp     
| exp CARET exp        
| CARET exp %prec UNARY
| exp CARETFSLASH exp
| CARETFSLASH exp %prec UNARY
| '(' exp ')'
| lambda
;
*/

/*
lambda: 
  caparglist parlist EQRANGLE exp
  ;
*/

commalist:
  %empty
  | commalist COMMA
    /*{ $$ += $2; }*/
  | commalist ID
    /*{ $$ += $2; }*/
  ;

parlist:    LPAR   commalist RPAR
/*
//not used yet
bracklist:  LBRACK commalist RBRACK
bracelist:  LBRACE commalist RBRACE
*/
anglelist:  LANGLE commalist RANGLE

class:
  CLASS decl INDENT body
  {
    #ifdef DEBUG
        //cout << "class:" << $2 << endl;
    #endif
  }
;

body:
  any 
  | body any
;

struct_decl:
  STRUCT decl INDENT
;

func_decl: 
  FUNC decl parlist INDENT
;

/*
method: %empty;
assert: %empty;
*/
    
decl:
  ID
  | ID anglelist
;
  

%%

/****************
 Additional Code
 ****************/

using location_type = long;

//void yy::parser::error(const syntax_error& err)
void yy::parser::error(const location_type& loc, const std::string& msg)
{
  std::cerr << loc <<":\t" << msg << std::endl;
}

int main(void)
{
  Lexer.lex();
  return yy::parse();
}



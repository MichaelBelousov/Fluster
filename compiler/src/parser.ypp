/* Fluster Bison Grammar */

%require "3.4"

/*%define api.language "c++"*/
%skeleton "lalr1.cc"
%define api.token.constructor
%printer { yyo << $$; } <*>;
%define api.value.type variant

/* can switch to custom type here */
%define parse.assert

%{
#include <iostream>
#define DEBUG
%}

%code requires {
  #include <string>
  #include "ast/base.h"
  /*
  namespace yy {
    class Lexer;
  }
  */
}

%param { Driver& driver }

%locations
%define parse.trace
%define parse.error verbose
%define api.namespace {fluster}
%define api.location.file "location.gen.h"
%define api.parser.class {Parser}
%define api.prefix {}
%parse-param { yy::Lexer& lexer }

%code{
  #include "driver.h"
  #include "lexer.h"
  //#undef yylex
  //#define yylex lexer.yylex
}

/*%define api.token.prefix {TOK_}*/
/* tokens */
/* TODO: reorder by precendence */

/* control tokens */
%token      EOF         0       "EOF"
%token      INDENT
%token      OUTDENT
%token      NL                  "\n"
/* assignment (lowest precedence)  */
%right      EQ                  "="         /* value assignment */
/* comparision/relational operators */
%nonassoc   LANGLE              "<"         /* less than */
%nonassoc   LANGLE_EQ           "<="        /* less than or equal to */
%nonassoc   EQ_EQ               "=="        /* value comparison */
%nonassoc   EXCLAIM_EQ          "!="        /* complement of value comparison */
%nonassoc   HASH_EQ             "#="        /* identity comparision */
%nonassoc   LANGLE_EQ_RANGLE    "<=>"       /* ternary comparison */
%nonassoc   RANGLE_EQ           ">="        /* greater than or equal to */
%nonassoc   RANGLE              ">"         /* greater than */
/* unary operations */
%nonassoc   TILDE               "~"         /* complement */
%token      EXCLAIM             "!"         /* mutable type */
%right      COMPLEMENT          /* ~t */
%right      NEGATE              /* -t */
%right      TYPE_MUT            /* !T */
%right      TYPE_ARRAY          /* [N]T */
%right      TYPE_PTR            /* *T */
%right      TYPE_REF            /* &T */
%right      TYPE_IS             /* is T */
%right      TYPE_HAS            /* has T */
%right      UNARY_MINUS         /* unary minus */
%right      PREINCREMENT        /* ++a */
%right      PREDECREMENT        /* --a */
%right      POSTINCREMENT       /* a++ */
%right      POSTDECREMENT       /* a-- */
/* binary arithmetic tokens */
%left       PLUS                "+"         /* addition, structural type inheritance */
%left       DASH                "-"         /* subtraction */
%left       STAR                "*"         /* multiplication */
%left       FSLASH              "/"         /* division */
%left       FSLASH_FSLASH       "//"        /* integer division (yields tuple of result and remainder) */
%left       PERCENT             "%"         /* modular division? */
%left       CARET               "^"         /* bitwise xor, power */
%left       CARET_FSLASH        "^/"        /* binary root, unary square root */
%nonassoc   HAS                 "has"       /* composition/implementation, type implementors qualifier */
%nonassoc   IS                  "is"        /* inheritance, type inheritance qualifier */
%left       AMPERSAND           "&"         /* logical and, bitwise and, set intersection, structural type intersection */
%left       PIPE                "|"         /* logical or, bitwise or, set union, structural type union */
%left       RANGLE_RANGLE       ">>"        /* bitwise shift right */
%left       LANGLE_LANGLE       "<<"        /* bitwise shift left */
%left       DASH_RANGLE         "->"        /* logical implication, case indication */
%right      PLUS_EQ             "+="        /* addition assignment */
%right      DASH_EQ             "-="        /* subtraction assignment */
%right      STAR_EQ             "*="        /* multiplication assignment */
%right      FSLASH_EQ           "/="        /* division assignment */
%right      FSLASH_FSLASH_EQ    "//="       /* integer division assignment (discards remainder) */
%right      CARET_FSLASH_EQ     "^/="       /* root assignment */
%right      CARET_EQ            "^="        /* bitwise xor assignment, power assignment */
%right      AMPERSAND_EQ        "&="        /* ampersand assignment */
%right      PIPE_EQ             "|="        /* pipe assignment */
%right      TILDE_EQ            "~="        /* complement assignment */
%right      RANGLE_RANGLE_EQ    ">>="       /* right-shift assignment */
%right      LANGLE_LANGLE_EQ    "<<="       /* left-shift assignment */
%left       DASH_RANGLE_EQ      "->="       /* implication assignment */
%right      PLUS_PLUS           "++"        /* increment */
%right      DASH_DASH           "--"        /* decrement */
%nonassoc   DOLLAR              "$"         /* unknown */
/* %left     LANGLE_DASH         "<-"          CONFLICT since '-' is unary" */
%nonassoc   DOT                 "."         /* hierarchical/structural access */
%nonassoc   DOT_DOT             ".."        /* slice range opening, pack expansion, pack declaration */
%nonassoc   DOT_DOT_DOT         "..."       /* empty */
%nonassoc   LBRACK              "["         /* start access expression, start list literal */
%nonassoc   RBRACK              "]"         /* end access expression, end list literal */
%nonassoc   LBRACE              "{"         /* start set or object type/value expression */
%nonassoc   RBRACE              "}"         /* end set or object type/value expression */
%nonassoc   LPAR                "("         /* start separate expression, start tuple literal, start invoke */
%nonassoc   RPAR                ")"         /* end separate expression, end tuple literal, end invoke */
%left       COMMA               ","         /* separate values */
%right      EQ_RANGLE           "=>"        /* anonymous function */
%right      COLON               ":"         /* type assertion */
%right      SEMICOLON           ";"         /* chain and discard expressions */
%nonassoc   AT                  "@"         /* decorator invocation */
%nonassoc   QUES                "?"         /* optional type */
%right      IN                  "in"        /* containment expression */
%right      CONTAINS            "contains"  /* containment expression */
%left       MOD                 "mod"       /* modular division */
%nonassoc   IF                  "if"        /* start if statement */
%nonassoc   ELSE                "else"      /* start else statement */
%nonassoc   ELIF                "elif"      /* start else if statement */
%nonassoc   FOR                 "for"       /* start for loop */
%nonassoc   WHILE               "while"     /* start while loop */
%nonassoc   UNTIL               "until"     /* start until loop */
%nonassoc   REPEAT              "repeat"    /* start infinite loop */
%nonassoc   TRY                 "try"       /* attempt expression */
%nonassoc   RETRY               "retry"     /* retry attempted expression */
%nonassoc   HANDLE              "handle"    /* declare exception handling case */
%nonassoc   RAISE               "raise"     /* raise an exception case */
%nonassoc   WITH                "with"      /* declare context */
%nonassoc   STRUCT              "struct"    /* declare structure */
%nonassoc   CLASS               "class"     /* declare dynamic-type reference structure */
%nonassoc   TYPEOF              "typeof"    /* get type of expression */
%nonassoc   CLONEOF             "cloneof"   /* get clone of type */
%nonassoc   IMPORT              "import"    /* import a path */
/*ast::Identifier*/
%token <ast::Identifier> Identifier
%token <data::NaturalNum> Integer_literal
%token <data::RationalNum> Float_literal
%token <data::ByteArray> Bytes_literal
%token <data::BitArray> Bits_literal
%token <data::String> String_literal

%type <ast::Node::Ptr> expr
%type <ast::Node::Ptr> statement
%type <ast::Node::Ptr> lambda_body
%type <ast::Node::Ptr> code
%type <ast::Node::Ptr> block
%type <ast::Node::Ptr> elifs
%type <ast::Node::Ptr> if
%type <ast::Node::Ptr> line
%type <ast::Node::Ptr> lambda_expr
%type <ast::Node::Ptr> commalist_
%type <ast::Node::Ptr> commalist
%type <ast::Node::Ptr> Par_list
%type <ast::Node::Ptr> Brack_list
%type <ast::Node::Ptr> Brace_list
%type <ast::Node::Ptr> Angle_list


%start input

%%
/**************************
 Grammer Rules and Actions
 **************************/
/* ops */
/* %left PLUS DASH               /*|   + -       |*/
/* %left STAR FSLASH TWOFSLASH   /*|   * / //    |*/
/* %right CARET CARETFSLASH      /*|   ^ ^/      |*/
/* %precedence UNARY             /*|   ^ ^/ -    |*/
/*** structure ***/
input
  : %empty
  | input code
  ;

code
  : %empty
    { $$ = ast::CodeBlock::empty(); }
  | code line
    { $$ = $1.append($2); }
  ;

line
  : expr NL
    { $$ = $1; }
  | NL
    { $$ = ast::Expression::empty(); }
  | statement NL
    { $$ = $1; }
  | error
    { yy::errok(); }
  ;

block
  : INDENT code OUTDENT
    { $$ = ast::CodeBlock($2); }
  ;

/* Expressions */
statement
  : if
    { $$ = ast::Expression($1); }
  ;


expr
  /* atomic */
  : Identifier
    { $$ = rt::symbol[$1]; }
  | String_literal
    { $$ = ast::StringLiteral($1); }
  | Integer_literal
    { $$ = ast::IntegerLiteral($1); }
  | Float_literal
    { $$ = ast::FloatLiteral($1); }
  | '(' expr ')'
    { $$ = $2; }
  /* prefix */
  | "++" expr
    %prec PREINCREMENT
    { $$ = ast::ops::PreIncrement($2); }
  | "--" expr
    %prec PREDECREMENT
    { $$ = ast::ops::PreDecrement($2); }
  | "-" expr
    %prec UNARY_MINUS
    { $$ = ast::ops::PreDecrement($2); }
  | "^/" expr
    { $$ = ast::ops::Root(2, $2); }
  /* postfix */
  | expr "++"
    { $$ = ast::ops::PostIncrement($1); }
  | expr "--"
    { $$ = ast::ops::PostDecrement($1); }
  /* binary */
  | expr PLUS expr
    { $$ = ast::ops::Add($1, $3); }
  | expr DASH expr
    { $$ = ast::ops::Subtract($1, $3); }
  | expr STAR expr
    { $$ = ast::ops::Multiply($1, $3); }
  | expr FSLASH expr
    { $$ = ast::ops::Divide($1, $3); }
  | expr FSLASH_FSLASH expr
    { $$ = ast::ops::IntegerDivide($1, $3); }
  | expr CARET_FSLASH expr
    { $$ = ast::ops::Root($1, $3); }
  | expr CARET expr
    { $$ = ast::ops::Power($1, $3); }
  | expr EQ expr
    { $$ = ast::ops::Assign($1, $3); }
  | expr COLON expr
    { $$ = ast::ops::AssertType($1, $3); }
  /* other */
  | lambda_expr
    { $$ = ast::asBase($1); }
  ;

lambda_body
  : expr
    { $$ = ast::LambdaBody($1); }
  | NL block
    { $$ = ast::ResultHavingCode($2); }
  ;


lambda_expr
  : Par_list EQ_RANGLE lambda_body
    { $$ = ast::Lambda(args=$1, expr=$3); }
  ;

/* control flow */
if
  : IF expr NL
      block
    elifs
    { $$ = ast::IfStatement(condition=$2, then=$4); }
  | IF expr NL
      block
    elifs
    ELSE
      block
    { $$ = ast::IfStatement(condition=$2,
                            then=$4,
                            else_=ast::CodeBlock($5, $7)
      );
    }
  ;

elifs
  : %empty
    { $$ = ast::CodeBlock::empty(); }
  | elifs ELIF expr NL block
    { $$ = $1.append(
                ast::IfStatement(condition=$3,
                                 then=$5
      ));
    }
  ;

commalist_
  : expr
    { $$ = ast::CommaDelimitedList::fromFirst($1); }
  | commalist_ COMMA expr
    { $$ = $1.append($3); }
  ;

commalist
  : commalist_
    { $$ = ast::CommaDelimitedList($1); }
  ;

Par_list
  : '(' commalist ')'
    { $$ = $2; }
  ;

Brack_list
  : '[' commalist ']'
    { $$ = $2; }
  ;

Brace_list
  : '{' commalist '}'
    { $$ = $2; }
  ;

Angle_list
  : '<' commalist '>'
    { $$ = $2; }
  ;


%%


// TODO: define elsewhere
using location_type = long;

//void yy::parser::error(const syntax_error& err)

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  std::cerr << loc <<":\t" << msg << std::endl;
}

/*
int main(void)
{
  Lexer.lex();
  return yy::parse();
}
*/

/*
This is the RE/flex lexer specification
for the fluster language. RE/flex generates
efficient C++ lexing/scanning code from
this specification.
*/

%top{
  #include "parser.gen.h"
  //#include "driver.h"
  #include "lexer_routines.h"
%}

 /* additional members of the Lexer class */
%class{
%}

 /* additional initialization of Lexer objects */
%init{
%}

/*** Definitions ***/


id                  [_a-zA-Z][_a-zA-Z0-9]*
digit               [0-9]
bit                 [01]
hex                 [0-9a-fA-F]
octal               [0-7]
decnum_start        [1-9]+
decint              {decnum_start}{digit}*
any                 .|\n
string_content      {any}*[^\\]


/*** Options***/

%o debug

%o reentrant
%o noyywrap nounput noinput batch debug
%o namespace=yy
%o lexer=Lexer
%o bison-complete
%o bison-cc-parser=Parser
%o bison-locations

%o tabs=4

%o exception="yy::Parser::syntax_error(location(), \"unknown token.\")"

/*** States ***/

/* backslash handling states */
%x  INNER_BACKSLASH_EMIT_INDENT
%s  INNER_BACKSLASH_EMIT_NL
%x  INNER_BACKSLASH_EMIT_OUTDENT

%%


 /*** Operators ***/

"<"             return yy::Parser::make_S_LANGLE(location());
"<="            return yy::Parser::make_S_LANGLE_EQ(location());
"=="            return yy::Parser::make_S_EQ_EQ(location());
"#="            return yy::Parser::make_S_HASH_EQ(location());
"!#="           return yy::Parser::make_S_EXCLAIM_HASH_EQ(location());
"<=>"           return yy::Parser::make_S_LANGLE_EQ_RANGLE(location());
"~"             return yy::Parser::make_S_TILDE(location());
"!="            return yy::Parser::make_S_EXCLAIM_EQ(location());
"!"             return yy::Parser::make_S_EXCLAIM(location());
">="            return yy::Parser::make_S_RANGLE_EQ(location());
">"             return yy::Parser::make_S_RANGLE(location());
"+"             return yy::Parser::make_S_PLUS(location());
"-"             return yy::Parser::make_S_DASH(location());
"*"             return yy::Parser::make_S_STAR(location());
"/"             return yy::Parser::make_S_FSLASH(location());
"//"            return yy::Parser::make_S_FSLASH_FSLASH(location());
"%"             return yy::Parser::make_S_PERCENT(location());
"^"             return yy::Parser::make_S_CARET(location());
"^/"            return yy::Parser::make_S_CARET_FSLASH(location());
\<has\>         return yy::Parser::make_S_HAS(location());
\<is\>          return yy::Parser::make_S_IS(location());
"&"             return yy::Parser::make_S_AMPERSAND(location());
"|"             return yy::Parser::make_S_PIPE(location());
">>"            return yy::Parser::make_S_RANGLE_RANGLE(location());
"<<"            return yy::Parser::make_S_LANGLE_LANGLE(location());
"->"            return yy::Parser::make_S_DASH_RANGLE(location());
"="             return yy::Parser::make_S_EQ(location());
"+="            return yy::Parser::make_S_PLUS_EQ(location());
"-="            return yy::Parser::make_S_DASH_EQ(location());
"*="            return yy::Parser::make_S_STAR_EQ(location());
"/="            return yy::Parser::make_S_FSLASH_EQ(location());
"//="           return yy::Parser::make_S_FSLASH_FSLASH_EQ(location());
"^/="           return yy::Parser::make_S_CARET_FSLASH_EQ(location());
"^="            return yy::Parser::make_S_CARET_EQ(location());
"&="            return yy::Parser::make_S_AMPERSAND_EQ(location());
"|="            return yy::Parser::make_S_PIPE_EQ(location());
"~="            return yy::Parser::make_S_TILDE_EQ(location());
">>="           return yy::Parser::make_S_RANGLE_RANGLE_EQ(location());
"<<="           return yy::Parser::make_S_LANGLE_LANGLE_EQ(location());
"->="           return yy::Parser::make_S_DASH_RANGLE_EQ(location());
"."             return yy::Parser::make_S_DOT(location());
".."            return yy::Parser::make_S_DOT_DOT_DOT(location());
"..."           return yy::Parser::make_S_DOT_DOT_DOT(location());
"["             return yy::Parser::make_S_LBRACK(location());
"]"             return yy::Parser::make_S_RBRACK(location());
"{"             return yy::Parser::make_S_LBRACE(location());
"}"             return yy::Parser::make_S_RBRACE(location());
"("             return yy::Parser::make_S_LPAR(location());
")"             return yy::Parser::make_S_RPAR(location());
","             return yy::Parser::make_S_COMMA(location());
"=>"            return yy::Parser::make_S_EQ_RANGLE(location());
":"             return yy::Parser::make_S_COLON(location());
"@"             return yy::Parser::make_S_AT(location());
"?"             return yy::Parser::make_S_QUES(location());

 /*** Keywords ***/
\<in\>          return yy::Parser::make_S_IN(location());
\<mod\>         return yy::Parser::make_S_MOD(location());

\<if\>          return yy::Parser::make_KW_IF(location());
\<else\>        return yy::Parser::make_KW_ELSE(location());
\<elif\>        return yy::Parser::make_KW_ELIF(location());
\<for\>         return yy::Parser::make_KW_FOR(location());
\<while\>       return yy::Parser::make_KW_WHILE(location());
\<until\>       return yy::Parser::make_KW_UNTIL(location());
\<repeat\>      return yy::Parser::make_KW_REPEAT(location());
\<case\>        return yy::Parser::make_KW_CASE(location());
\<try\>         return yy::Parser::make_KW_TRY(location());
\<retry\>       return yy::Parser::make_KW_RETRY(location());
\<handle\>      return yy::Parser::make_KW_HANDLE(location());
\<raise\>       return yy::Parser::make_KW_RAISE(location());
\<with\>        return yy::Parser::make_KW_WITH(location());
\<struct\>      return yy::Parser::make_KW_STRUCT(location());
\<class\>       return yy::Parser::make_KW_CLASS(location());

\<typeof\>      return yy::Parser::make_KW_TYPEOF(location());
\<cloneof\>     return yy::Parser::make_KW_CLONEOF(location());
\<import\>      return yy::Parser::make_KW_IMPORT(location());


/*** atomic expressions ***/


{id}                                        //return make_Identifier(str(), location());

  /* int literals */
{decint}                                    return make_IntegerLiteral(str(), location());

  /* float literal */
{decint}(\.{digit}+)?([Ee][+-]?{digit}+)?   return make_FloatLiteral(str(), location());

  /* byte literals */
0x{hex}*                                    //return make_HexBytesLiteral(str(), location());

  /* bit literal */
0b{bit}*                                    //return make_BinaryBitsLiteral(str(), location());

  /* octal literal */
0o{octal}*                                  //return make_OctalBitsLiteral(str(), location());

  /* string literal */
\"(?u:{string_content})\"                   return make_StringLiteral(str(), location());

  /* raw string literal */
\`(?u:{string_content})\`                   //return make_RawStringLiteral(str(), location());


/*** comments ***/


  /* multiline comment */
"/*"{any}*?"*/"                             //ignore

  /* eol comment */
"//".*                                      //ignore


/*** control ***/

  /* eof */
<<EOF>>                                     return yy::Parser::make_S_END(location());



/*** indentation ***/

^\h*\i          return yy::Parser::make_S_INDENT(location());
^\h*\j          return yy::Parser::make_S_OUTDENT(location());

\j              return yy::Parser::make_S_OUTDENT(location());

(?^\\\n\h*)     //ignore space after line-end backslash

  /* skip NL */
\\$             //will need to do some exclusive states here

  /* return NL, INDENT, *, NL, OUTDENT */
\\              { start(INNER_BACKSLASH_EMIT_INDENT);
                  return yy::Parser::make_S_NL(location());
                }

<INNER_BACKSLASH_EMIT_INDENT>. {
                  start(INNER_BACKSLASH_EMIT_OUTDENT);
                  return yy::Parser::make_S_INDENT(location());
                }

<INNER_BACKSLASH_EMIT_NL>\n {
                  start(INNER_BACKSLASH_EMIT_OUTDENT);
                  return yy::Parser::make_S_NL(location());
                }
<INNER_BACKSLASH_EMIT_OUTDENT>. {
                  start(INITIAL);
                  return yy::Parser::make_S_OUTDENT(location());
                }



%%

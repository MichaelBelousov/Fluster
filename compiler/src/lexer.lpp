/*
This is the RE/flex lexer specification
for the fluster language. RE/flex generates
efficient C++ lexing/scanning code from
this specification.
*/

%top{
  #include "parser.gen.h"
  #include "driver.h"
  #include "lexer_routines.h"
%}

 /* additional members of the Lexer class */
%class{
%}

 /* additional initialization of Lexer objects */
%init{
%}

/*** Definitions ***/


id                  [_a-zA-Z][_a-zA-Z0-9]*
digit               [0-9]
bit                 [01]
hex                 [0-9a-fA-F]
octal               [0-7]
decnum_start        [1-9]+
decint              {decnum_start}{digit}*
any                 .|\n
string_content      {any}*[^\\]


/*** Options***/

%o debug

%o reentrant
%o noyywrap nounput noinput batch debug
%o namespace=yy
%o lexer=Lexer
%o bison-complete
%o bison-cc-parser=Parser
%o bison-locations

%o tabs=4

%o exception="yy::Parser::syntax_error(location(), \"unknown token.\")"

/*** States ***/

/* backslash handling states */
%x  INNER_BACKSLASH_EMIT_INDENT
%s  INNER_BACKSLASH_EMIT_NL
%x  INNER_BACKSLASH_EMIT_OUTDENT

%%


 /*** Operators ***/

"<"             return yy::Parser::make_S_LANGLE(loc);
"<="            return yy::Parser::make_S_LANGLE_EQ(loc);
"=="            return yy::Parser::make_S_DOUBLE_EQ(loc);
"#="            return yy::Parser::make_S_HASH_EQ(loc);
"!#="           return yy::Parser::make_S_EXCLAIM_HASH_EQ(loc);
"<=>"           return yy::Parser::make_S_LANGLE_EQ_RANGLE(loc);
"~"             return yy::Parser::make_S_TILDE(loc);
"!="            return yy::Parser::make_S_EXCLAIM_EQ(loc);
"!"             return yy::Parser::make_S_EXCLAIM(loc);
">="            return yy::Parser::make_S_RANGLE_EQ(loc);
">"             return yy::Parser::make_S_RANGLE(loc);
"+"             return yy::Parser::make_S_PLUS(loc);
"-"             return yy::Parser::make_S_DASH(loc);
"*"             return yy::Parser::make_S_STAR(loc);
"/"             return yy::Parser::make_S_FSLASH(loc);
"//"            return yy::Parser::make_S_FSLASH_FSLASH(loc);
"%"             return yy::Parser::make_S_PERCENT(loc);
"^"             return yy::Parser::make_S_CARET(loc);
"^/"            return yy::Parser::make_S_CARET_FSLASH(loc);
\<has\>         return yy::Parser::make_S_HAS(loc);
\<is\>          return yy::Parser::make_S_IS(loc);
"&"             return yy::Parser::make_S_AMPERSAND(loc);
"|"             return yy::Parser::make_S_PIPE(loc);
">>"            return yy::Parser::make_S_RANGLE_RANGLE(loc);
"<<"            return yy::Parser::make_S_LANGLE_LANGLE(loc);
"->"            return yy::Parser::make_S_DASH_RANGLE(loc);
"="             return yy::Parser::make_S_EQ(loc);
"+="            return yy::Parser::make_S_PLUS_EQ(loc);
"-="            return yy::Parser::make_S_DASH_EQ(loc);
"*="            return yy::Parser::make_S_STAR_EQ(loc);
"/="            return yy::Parser::make_S_FSLASH_EQ(loc);
"//="           return yy::Parser::make_S_FSLASH_FSLASH_EQ(loc);
"^/="           return yy::Parser::make_S_CARET_FSLASH_EQ(loc);
"^="            return yy::Parser::make_S_CARET_EQ(loc);
"&="            return yy::Parser::make_S_AMPERSAND_EQ(loc);
"|="            return yy::Parser::make_S_PIPE_EQ(loc);
"~="            return yy::Parser::make_S_TILDE_EQ(loc);
">>="           return yy::Parser::make_S_RANGLE_RANGLE_EQ(loc);
"<<="           return yy::Parser::make_S_LANGLE_LANGLE_EQ(loc);
"->="           return yy::Parser::make_S_DASH_RANGLE_EQ(loc);
"$"             return yy::Parser::make_S_DOLLAR(loc);
"."             return yy::Parser::make_S_DOT(loc);
".."            return yy::Parser::make_S_DOT_DOT_DOT(loc);
"..."           return yy::Parser::make_S_DOT_DOT_DOT(loc);
"["             return yy::Parser::make_S_LBRACK(loc);
"]"             return yy::Parser::make_S_RBRACK(loc);
"{"             return yy::Parser::make_S_LBRACE(loc);
"}"             return yy::Parser::make_S_RBRACE(loc);
"("             return yy::Parser::make_S_LPAR(loc);
")"             return yy::Parser::make_S_RPAR(loc);
","             return yy::Parser::make_S_COMMA(loc);
"=>"            return yy::Parser::make_S_EQ_RANGLE(loc);
":"             return yy::Parser::make_S_COLON(loc);
"@"             return yy::Parser::make_S_AT(loc);
"?"             return yy::Parser::make_S_QUES(loc);

 /*** Keywords ***/
\<in\>          return yy::Parser::make_S_IN(loc);
\<mod\>         return yy::Parser::make_S_MOD(loc);

\<if\>          return yy::Parser::make_KW_IF(loc);
\<else\>        return yy::Parser::make_KW_ELSE(loc);
\<elif\>        return yy::Parser::make_KW_ELIF(loc);
\<for\>         return yy::Parser::make_KW_FOR(loc);
\<while\>       return yy::Parser::make_KW_WHILE(loc);
\<until\>       return yy::Parser::make_KW_UNTIL(loc);
\<repeat\>      return yy::Parser::make_KW_REPEAT(loc);
\<case\>        return yy::Parser::make_KW_CASE(loc);
\<try\>         return yy::Parser::make_KW_TRY(loc);
\<retry\>       return yy::Parser::make_KW_RETRY(loc);
\<handle\>      return yy::Parser::make_KW_HANDLE(loc);
\<raise\>       return yy::Parser::make_KW_RAISE(loc);
\<with\>        return yy::Parser::make_KW_WITH(loc);
\<struct\>      return yy::Parser::make_KW_STRUCT(loc);
\<class\>       return yy::Parser::make_KW_CLASS(loc);

\<typeof\>      return yy::Parser::make_KW_TYPEOF(loc);
\<cloneof\>     return yy::Parser::make_KW_CLONEOF(loc);
\<import\>      return yy::Parser::make_KW_IMPORT(loc);


 /*** identifier ***/

{id}                                        return yy::Parser::make_S_IDENTIFIER(yytext, loc);

 /*** literals ***/

  /* int literals */
{decint}                                    return yy::Parser::make_S_DECIMAL_INTEGER(yytext, loc);

  /* float literal */
{decint}(\.{digit}+)?([Ee][+-]?{digit}+)?   return yy::Parser::make_S_DECIMAL_FLOAT(yytext, loc);

  /* byte literals */
0x{hex}*                                    return yy::Parser::make_S_HEX_BYTES(yytext, loc);

  /* bit literal */
0b{bit}*                                    return yy::Parser::make_S_BINARY_BITS(yytext, loc);

  /* octal literal */
0o{octal}                                   return yy::Parser::make_S_OCTAL_BITS(yytext, loc);

  /* string literal */                    /* TODO: use a state to dedent source */
\"{string_content}\"                        return yy::Parser::make_S_STRING(yytext, loc);

  /* unicode literal */
u\"(?u:{string_content})\"                  return yy::Parser::make_S_UNICODE_STRING(yytext, loc);

  /* raw string literal */
\`{string_content}\`                        return yy::Parser::make_S_RAW_STRING(yytext, loc);



/*** comments ***/


  /* multiline comment */
"/*"(.|\n)*?"*/"                            //ignore

  /* eol comment */
"//".*                                      //ignore


/*** control ***/

  /* eof */
<<EOF>>                                     return yy::Parser::make_S_END(loc);



/*** indentation ***/

^\h*\i          return yy::Parser::make_S_INDENT;
^\h*\j          return yy::Parser::make_S_OUTDENT;

\j              return yy::Parser::make_S_OUTDENT;

(?^\\\n\h*)     //ignore space after line-end backslash

  /* skip NL */
\\$

  /* return NL, INDENT, *, NL, OUTDENT */
\\              { start(INNER_BACKSLASH_EMIT_INDENT)
                  return yy::Parser::make_S_NL;
                }

<INNER_BACKSLASH_EMIT_INDENT>.
                { start(INNER_BACKSLASH_EMIT_OUTDENT)
                  return yy::Parser::make_S_INDENT;
                }

<INNER_BACKSLASH_EMIT_NL>\n
                { start(INNER_BACKSLASH_EMIT_OUTDENT)
                  return yy::Parser::make_S_NL;
                }
<INNER_BACKSLASH_EMIT_OUTDENT>.
                { start(INITIAL)
                  return yy::Parser::make_S_OUTDENT;
                }



%%
